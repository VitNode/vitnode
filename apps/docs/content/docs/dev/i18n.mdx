---
title: Internationalization (i18n)
description: Translate your plugin to multiple languages.
---

VitNode supports multiple languages out of the box. You can easily translate your content inside plugin using `JSON` file. Input and WYSIWYG fields are supported also with i18n using `core_languages_words` database.

## Content

Thanks to [next-intl](https://next-intl-docs.vercel.app/) you can easily translate your content. Read more in the [official documentation](https://next-intl-docs.vercel.app/docs/usage).

To translate your content select the plugin in `frontend`, go to `langs` folder and pick the language you want to translate. You can also add a new language by creating a new one in AdminCP.

```json title="apps/frontend/src/plugins/{your_plugin}/langs/en.json"
{
  "{your_plugin}": {
    "hello": "Hello World",
    "world": "World"
  }
}
```

<Callout title="Primary key" type="warn">
  Name your plugin should be a primary key in the JSON file.

You cannnot do this:

```json title="apps/frontend/src/plugins/{your_plugin}/langs/en.json"
{
  "{your_plugin}": {
    "hello": "Hello World"
  },
  "world": "World"
}
```

</Callout>

## Translation Fields

VitNode has a built-in translation fields for input and WYSIWYG fields.

As an example, we will create a translation field for the `title (input)` and `content (WYSIWYG)` fields in the `core_terms` table.

import { Step, Steps } from 'fumadocs-ui/components/steps';

<Steps>
<Step>

### Database

For the translation fields, you need to create a new table in the database where you will store the translations.

```ts title="backend/plugins/{your_plugin}/admin/database/schema/terms.ts"
import { pgTable, serial, timestamp, varchar } from 'drizzle-orm/pg-core';

export const core_terms = pgTable('core_terms', {
  id: serial('id').primaryKey(),
  code: varchar('code').notNull().unique(),
  created: timestamp('created').notNull().defaultNow(),
  updated: timestamp('updated').notNull().defaultNow(),
  href: varchar('href'),
});
```

You can find more information about the database schema in the [documentation](/docs/dev/database).

As you can see in the example above, we haven't added the translation fields yet. We will add them in `service` later.

</Step>

<Step>

### DTO Object

For the translation fields to show data, you need to use `StringLanguage[]` type in the DTO for the object.

```ts title="backend/plugins/{your_plugin}/terms/show/show.dto.ts"
import { PageInfo, StringLanguage } from 'vtinode-backend';
import { Field, ObjectType } from '@nestjs/graphql';

@ObjectType()
export class ShowCoreTerms {
  @Field(() => [StringLanguage]) // [!code highlight]
  content: StringLanguage[]; // [!code highlight]

  @Field(() => [StringLanguage]) // [!code highlight]
  title: StringLanguage[]; // [!code highlight]
}

@ObjectType()
export class ShowCoreTermsObj {
  @Field(() => [ShowCoreTerms])
  edges: ShowCoreTerms[];

  @Field(() => PageInfo)
  pageInfo: PageInfo;
}
```

### DTO Input

For the translation fields to work in the input, you need to use `StringLanguage` type in the DTO for the input.

```ts title="backend/plugins/{your_plugin}/terms/create/create.dto.ts"
import {
  IsStringLanguageInput,
  StringLanguageInput,
  TransformStringLanguageInput,
} from 'vitnode-backend';
import { ArgsType, Field } from '@nestjs/graphql';
import { Transform } from 'class-transformer';
import { IsArray } from 'class-validator';

@ArgsType()
export class CreateAdminTermsSettingsArgs {
  @IsArray()
  @IsStringLanguageInput()
  @Transform(TransformStringLanguageInput)
  @Field(() => [StringLanguageInput]) // [!code highlight]
  content: StringLanguageInput[]; // [!code highlight]

  @IsArray()
  @IsStringLanguageInput()
  @Transform(TransformStringLanguageInput)
  @Field(() => [StringLanguageInput]) // [!code highlight]
  title: StringLanguageInput[]; // [!code highlight]
}
```

</Step>

<Step>

### Create / Edit Service

To create or edit translation fields you need to use `StringLanguageHelper` service with `parse()` method.

As an example, we will create a translation field for the `title` and `content` fields in the `core_terms` table.

```ts title="backend/plugins/{your_plugin}/terms/create/create.service.ts"
import { ShowCoreTerms } from '@/core/terms/show/show.dto';
import { core_terms } from '@/database/schema/terms';
import {
  DatabaseService,
  CustomError,
  StringLanguageHelper, // [!code highlight]
} from 'vitnode-backend';
import { Injectable } from '@nestjs/common';

import { CreateAdminTermsSettingsArgs } from './create.dto';

@Injectable()
export class CreateAdminTermsSettingsService {
  constructor(
    private readonly databaseService: DatabaseService,
    private readonly stringLanguageHelper: StringLanguageHelper, // [!code highlight]
  ) {}

  async create({
    title,
    content,
    href,
  }: CreateAdminTermsSettingsArgs): Promise<ShowCoreTerms> {
    const termExist = await this.databaseService.db.query.core_terms.findFirst({
      where: (table, { eq }) => eq(table.code, code),
    });

    if (termExist) {
      throw new CustomError({
        code: 'ALREADY_EXISTS',
        message: 'Term already exists',
      });
    }

    const [term] = await this.databaseService.db
      .insert(core_terms)
      .values({ href })
      .returning();

    // [!code word:stringLanguageHelper]
    const titleTerm = await this.stringLanguageHelper.parse({
      item_id: term.id,
      plugin_code: 'core',
      database: core_terms,
      data: title,
      variable: 'title',
    });

    const contentTerm = await this.stringLanguageHelper.parse({
      item_id: term.id,
      plugin_code: 'core',
      database: core_terms,
      data: content,
      variable: 'content',
    });

    return {
      ...term,
      title: titleTerm,
      content: contentTerm,
    };
  }
}
```

This method will create a translation inside `core_languages_words` table and processing content to send notifications, attachments, etc.

#### API Reference

import { TypeTable } from 'fumadocs-ui/components/type-table';

<TypeTable
  type={{
    item_id: {
      description: 'Item ID from the main table.',
      type: 'number',
    },
    plugin_code: {
      description: 'Plugin code.',
      type: 'string',
    },
    database: {
      description: 'Database schema.',
      type: 'DatabaseSchema',
    },
    data: {
      description: 'Data to parse.',
      type: 'StringLanguageInput[]',
    },
    variable: {
      description: 'Variable name.',
      type: 'string',
    },
  }}
/>

</Step>

<Step>

### Delete Service

As we mention before, when you create or edit translation fields then our `parser()` method will processing content. To delete translations and other things related to it you need to use `delete()` method.

```ts title="backend/plugins/{your_plugin}/terms/delete/delete.service.ts"
import { core_terms } from '@/database/schema/terms';
import {
  DatabaseService,
  StringLanguageHelper,
  NotFoundError,
} from 'vitnode-frontend';
import { Injectable } from '@nestjs/common';
import { eq } from 'drizzle-orm';

@Injectable()
export class DeleteAdminTermsSettingsService {
  constructor(
    private readonly databaseService: DatabaseService,
    private readonly stringLanguageHelper: StringLanguageHelper,
  ) {}

  async delete({ code }: { code: string }): Promise<string> {
    const term = await this.databaseService.db.query.core_terms.findFirst({
      where: (table, { eq }) => eq(table.code, code),
      columns: {
        id: true,
      },
    });

    if (!term) {
      throw new NotFoundError('Term');
    }

    await this.databaseService.db
      .delete(core_terms)
      .where(eq(core_terms.id, term.id));

    // [!code word:stringLanguageHelper]
    await this.stringLanguageHelper.delete({
      database: core_terms,
      item_id: term.id,
      plugin_code: 'core',
    });

    return 'Term deleted!';
  }
}
```

<Callout
  title="Always delete translation when delete primary record!"
  type="error"
>
  This is important to delete translation. Otherwise, translations will be still
  in the database.
</Callout>

#### API Reference

<TypeTable
  type={{
    database: {
      description: 'Database schema.',
      type: 'DatabaseSchema',
    },
    item_id: {
      description: 'Item ID from the main table.',
      type: 'number',
    },
    plugin_code: {
      description: 'Plugin code.',
      type: 'string',
    },
  }}
/>

</Step>

<Step>

### Show Service

`core_languages_words` table doesn't have relation so you need to use `StringLanguageHelper` service with `show()` to get translations.

In return service we will filter translation by `item_id` and `variable` to get the correct translation for the `title` and `content` fields.

```ts title="backend/plugins/{your_plugin}/terms/show/show.service.ts"
import { core_terms } from '@/database/schema/terms';
import {
  InternalDatabaseService,
  SortDirectionEnum,
  inputPaginationCursor,
  outputPagination,
  StringLanguageHelper,
} from 'vitnode-backend';
import { Injectable } from '@nestjs/common';
import { and, count, eq } from 'drizzle-orm';

import { ShowCoreTermsArgs, ShowCoreTermsObj } from './show.dto';

@Injectable()
export class ShowCoreTermsService {
  constructor(
    private readonly databaseService: InternalDatabaseService,
    private readonly stringLanguageHelper: StringLanguageHelper, // [!code highlight]
  ) {}

  async show({
    cursor,
    first,
    last,
    code,
  }: ShowCoreTermsArgs): Promise<ShowCoreTermsObj> {
    const pagination = await inputPaginationCursor({
      cursor,
      database: core_terms,
      databaseService: this.databaseService,
      first,
      last,
      primaryCursor: {
        column: 'id',
        schema: core_terms.id,
      },
      defaultSortBy: {
        direction: SortDirectionEnum.desc,
        column: 'updated',
      },
    });

    const edgesFromDb = await this.databaseService.db.query.core_terms.findMany(
      {
        ...pagination,
      },
    );
    const ids = edgesFromDb.map(edge => edge.id);
    // [!code word:stringLanguageHelper]
    const i18n = await this.stringLanguageHelper.get({
      item_ids: ids,
      database: core_terms,
      plugin_code: 'core',
      variables: ['title', 'content'],
    });

    const totalCount = await this.databaseService.db
      .select({ count: count() })
      .from(core_terms);

    return outputPagination({
      edges: edgesFromDb.map(edge => {
        const currentI18n = i18n.filter(item => item.item_id === edge.id); // [!code highlight]

        return {
          ...edge,
          title: currentI18n.filter(value => value.variable === 'title'), // [!code highlight]
          content: currentI18n.filter(value => value.variable === 'content'), // [!code highlight]
        };
      }),
      totalCount,
      first,
      cursor,
      last,
    });
  }
}
```

</Step>

</Steps>

---

## Display text

On the frontend you can display text depends on display language.

### Using hook

```tsx title="example.tsx"
import { useTextLang } from 'vitnode-frontend/hooks/use-text-lang';

import { StringLanguage } from '@/utils/graphql/graphql';

interface Props {
  value: StringLanguage[];
}

export const ExampleComponent = ({ value }: Props) => {
  const { convertText } = useTextLang(); // [!code highlight]

  return <div>{convertText(value)}</div>;
};
```

### Using function (async component)

```tsx title="example.tsx"
import { useTextLang } from 'vitnode-frontend/hooks/use-text-lang';

import { StringLanguage } from '@/utils/graphql/graphql';

interface Props {
  value: StringLanguage[];
  locale: string;
}

export const ExampleComponent = async ({ locale, value }: Props) => {
  const { convertText } = getTextLang({ locale }); // [!code highlight]

  return <div>{convertText(value)}</div>;
};
```

## Form

Create form with translations is very similar to normal [Forms](/docs/ui/forms).

<Steps>

<Step>
### Define schema

```ts title="use-example.ts"
import * as z from 'zod';
import { zodLanguageInput } from 'vitnode-frontend/helpers/zod';

export const useExample = () => {
  const formSchema = z.object({
    title: zodLanguageInput,
  });
};
```

You can set `maxLength`:

```ts title="use-example.ts"
const formSchema = z.object({
  content: zodLanguageInput
    .min(1, {
      message: t('errors.required'),
    })
    .refine(value => value.every(item => item.value.length <= 100), {
      message: t('errors.max_length', { length: 100 }),
    }),
});
```

</Step>

<Step>
### Set initial values

```ts title="example.ts"
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { zodLanguageInput } from 'vitnode-frontend/helpers/zod';

export const useExample = () => {
  const formSchema = z.object({
    title: zodLanguageInput,
  });

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: [], // [!code highlight]
    },
  });

  const onSubmit = (values: z.infer<typeof formSchema>) => {
    // Do something
  };

  return { form, onSubmit };
};
```

</Step>

<Step>

### Form Field

```tsx
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from 'vitnode-frontend/components/ui/form';
import { StringLanguageInput } from 'vitnode-frontend/components/ui/text-language-input'; // [!code highlight]

import { useExample } from './use-example';

export const ExampleForm = () => {
  const { form, onSubmit } = useExample();

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Title</FormLabel>
              <FormControl>
                <StringLanguageInput {...field} /> // [!code highlight]
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button
          disabled={!form.formState.isValid}
          loading={form.formState.isSubmitting}
          type="submit"
        >
          Create
        </Button>
      </form>
    </Form>
  );
};
```

Instead of `StringLanguageInput` you can use `Editor` component. [Read more](/docs/ui/forms/editor).

</Step>

</Steps>
